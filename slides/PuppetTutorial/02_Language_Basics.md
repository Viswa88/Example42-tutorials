# Language Basics - Overview

### Introduction to Puppet language and terms

### Resource types

### Classes and defines

### Variables and parameters

### Nodes classification


# Puppet Language

A **Declarative** Domain Specific Language (DSL)

It defines **STATES** (Not procedures)

Puppet code is written in **manifests** (files with **.pp** extension)

In the code we declare **resources** that affect elements of the system (files, packages, services ...)

Resources are grouped in **classes** which may expose parameters that affect their behavior.

Classes and configuration files are organized in **modules**.

Consult the **[official glossary](https://docs.puppetlabs.com/references/glossary.html)** to give the correct meaning to Puppet terms

# Nodes classification

When clients connect, the Puppet Master generates a **catalog** with the list of of the resources that clients have to apply locally.

The Puppet Master has to *classify* nodes and define for each of them:

  The **classes** to include
  The **parameters** to pass
  The Puppet **environment** to use

The **catalog** is generated by the Master according to the logic of our Puppet code and data.

In our code we can define our **variables** and use other ones that may come from different sources:

  **facts** generated directly by the client
  **parameters** obtained from node's classification
  Puppet **internal** variables



# Resource Types (Types)

Resource Types are single **units of configuration** composed by:

A **type** (package, service, file, user, mount, exec ...)

A **title** (how is called and referred)

Zero or more **arguments**

    type { 'title':
      argument  => value,
      other_arg => value,
    }

Example for a **file** resource type:

    file { 'motd':
      path    => '/etc/motd',
      content => 'Tomorrow is another day',
    }


# Resource Types reference

Find online the complete [Type Reference](http://docs.puppetlabs.com/references/latest/type.html) for the latest or earlier versions.

From the shell the command line interface:

    puppet describe file

For the full list of available descriptions try:

    puppet describe --list


Give a glance to Puppet code for the list of **native** resource types:

    ls $(facter rubysitedir)/puppet/type


# Simple samples of resources

Installation of OpenSSH package

    package { 'openssh':
      ensure => present,
    }

Creation of /etc/motd file

    file { 'motd':
      path => '/etc/motd',
    }

Start of httpd service

    service { 'httpd':
      ensure => running,
      enable => true,
    }


# More complex samples of resources

Management of nginx service with parameters defined in module's variables

    service { 'nginx':
      ensure     => $::nginx::manage_service_ensure,
      name       => $::nginx::service_name,
      enable     => $::nginx::manage_service_enable,
    }

Creation of nginx.conf with content retrieved from different sources (first found is served)

    file { 'nginx.conf':
      ensure  => present,
      path    => '/etc/nginx/nginx.conf',
      source  => [
          "puppet:///modules/site/nginx.conf--${::fqdn}",
          "puppet:///modules/site/nginx.conf" ],
    }


# Resource Abstraction Layer

Resources are abstracted from the underlying OS

Resource **types** have different providers for different OS

The ```package``` type is known for the great number of **providers**

    ls $(facter rubysitedir)/puppet/provider/package

Use **puppet resource** to interrogate the RAL:

    puppet resource user

    puppet resource user root

    puppet resource package

    puppet resource service

Or to directly modify resources:

    puppet resource service httpd ensure=running enable=true


# Classes - Definition

Classes are **containers** of different resources. Since Puppet 2.6 they can have parameters

Example of a class **definition**:

    class mysql (
      root_password => 'default_value',
      port          => '3306',
    ) {
      package { 'mysql-server':
        ensure => present,
      }
      service { 'mysql':
        ensure    => running,
      }
      [...]
    }

Note that when we define a class we just describe what it does and what parameters it has, we don't actually add it and its resources to the catalog.

# Classes - Declaration
When we have to use a class previously defined, we **declare** it.

This can be done in 2 different ways:

"Old style" class declaration, without parameters:

    include mysql

(Inside a catalog we can have multiple includes of the same class but that class it's applied only once.)

"New style" (from Puppet 2.6) class declaration with explicit parameters:

    class { 'mysql':
      root_password => 'my_value',
      port          => '3307',
    }

(Syntax is the same of normal resources and the same class can be declared, in this way, only once inside the same catalog)

# Defines

Also called: **Defined resource types** or **defined types**

Similar to parametrized classes but can be used multiple times (with different titles).

**Definition** of a define:

    define apache::virtualhost (
      $ensure   = present,
      $template = 'apache/virtualhost.conf.erb' ,
      [...] ) {

      file { "ApacheVirtualHost_${name}":
        ensure  => $ensure,
        content => template("${template}"),
      }
    }

**Declaration** of a define:

    apache::virtualhost { 'www.example42.com':
      template => 'site/apache/www.example42.com-erb'
    }


# Variables

We need them to provide different configurations for different kind of servers.

They can be defined in different places and by different actors:

Can be provided by client nodes as **facts**

Can be **defined by users** in Puppet code, on Hiera on in the ENC

Can be **built-in** and be provided directly by Puppet


# Facts

**Facter** runs on clients and collects **facts** that the server can use as variables

    al$ facter

    architecture => x86_64
    fqdn => Macante.example42.com
    hostname => Macante
    interfaces => lo0,eth0
    ipaddress => 10.42.42.98
    ipaddress_eth0 => 10.42.42.98
    kernel => Linux
    macaddress => 20:c9:d0:44:61:57
    macaddress_eth0 => 20:c9:d0:44:61:57
    memorytotal => 16.00 GB
    netmask => 255.255.255.0
    operatingsystem => Centos
    operatingsystemrelease => 6.3
    osfamily => RedHat
    virtual => physical


# User Variables

We can define custom variables in different ways:

#### In Puppet **manifests**:

        $role = 'mail'

        $package = $::operatingsystem ? {
          /(?i:Ubuntu|Debian|Mint)/ => 'apache2',
          default                   => 'httpd',
        }

#### In an **External Node Classifier** (ENC)

Commonly used ENC are Puppet DashBoard, the Foreman, Puppet Enterprise.

#### In an **Hiera** backend

        $syslog_server = hiera(syslog_server)


# Built-in variables

Puppet provides some useful built in variables, they can be:

#### Set by the client (agent)

```$clientcert``` - the name of the node's certificate. By default its ```$::fqdn```
```$clientversion``` - the Puppet version on the client

#### Set by the server (master)

```$environment``` (default: production) - the Puppet environment where are placed modules and manifests.
```$servername```, ```$serverip``` - the Puppet Master FQDN and IP
```$serverversion``` - the Puppet version on the server
```$settings::<name>``` - any configuration setting on the Master's ```puppet.conf```

#### Set by the server during catalog compilation

```$module_name``` - the name of the module that contains the current resource's definition
```$caller_module_name``` - the name of the module that contains the current resource's declaration


# Environments
Puppet environments allow isolation of Puppet code and data: for each environment we can have different paths manifest files, Hiera data and modules.

Puppet's environments DO NOT necessarily have to match the operational environments of our servers.

Environments mamanagement has changed from Puppet 3.6 onwards:

Earlier versions were based on so-called **Config file Environments** where each environment had to be defined in **puppet.conf**.

From 3.6 **directory environments** have been introduced and the older approach has been deprecated.

On Puppet 4.x only directory environments are supported.

# [Config file Environments](https://docs.puppetlabs.com/puppet/latest/reference/environments_classic.html)

The "old" config file environments are defined inside ```puppet.conf``` with a syntax like:

     [test]
       modulepath = $confdir/environments/test/modules:$condfir/modules
       manifest = $confdir/environments/test/manifests

For the default **production** environment there were the config parameters, now deprecated, ```manifest``` and ```modulepath``` in the ```[main]``` section.

# [Directory Environments](https://docs.puppetlabs.com/puppet/latest/reference/environments_configuring.html)

Directory Environments are configured in ```puppet.conf``` as follows:

    [main]
    environmentpath = $configdir/

Then inside the ```/etc/puppet/environments/$environment/``` directory we have:

    modules/   # Directory containing modules
    manifests/ # Directory containing site.pp
    environment.conf # Conf file for the environment


# Nodes - Default classification

A node is identified by the PuppetMaster by its **certname**, which defaults to the node's **fqdn**

In the first manifest file parsed by the Master, ```site.pp```, we can define nodes with a syntax like:

    node 'web01' {
      include apache
    }

We can also define a list of matching names:

    node 'web01' , 'web02' , 'web03' {
      include apache
    }

or use a regular expression:

    node /^www\d+$/ {
      include apache
    }

A node can inherit another node and include all the classes and variables defined for it, this feature is now deprecated and is not supported anymore on Puppet 4.


# Nodes classification via an ENC

Puppet can query an external source to retrieve the classes and the parameters to assign to a node. This source is called External Node Classifier (ENC) and can be anything that, when interrogated via a script with the clients' certname as first parameter, returns a yaml file with the list of classes and parameters.

Common ENC are **Puppet DashBoard**, **The Foreman** and **Puppet Enterprise** (where the functionality of ENC is enabled by default).

To enable the usage of an ENC set these parameters in ```puppet.conf```

    # Enable the usage of a script to classify nodes
    node_terminus = exec

    # Path of the script to execute to classify nodes 
    external_nodes = /etc/puppet/node.rb

# Nodes classification with Hiera

Hiera provides a **hiera_include** function that allows the inclusion of classes as defined on Hiera. This is an approach that can be useful when there's massive usage of Hiera as backend for Puppet data.

In ```/etc/puppet/manifests/site.pp``` just place:

    hiera_include('classes')

and place, as an array, the classes to include in our Hiera data source under the key ```classes```.


# The Catalog

The **catalog** is the complete list of resources, and their relationships, that the Puppet Master generates for the client.

It's the result of all the puppet code and logic that we define for a given node in our manifests and is applied on the client after it has been received from the master.

The client uses the RAL (Resource Abstraction Layer) to execute the actual system's commands that convert abstract resources like

    package { 'openssh': }

to their actual fullfillment on the system (```apt-get install openssh``` , ```yum install openssh``` ...).

The catalog is saved by the client in ```/var/lib/puppet/client_data/catalog/$certname.json```


# Language Basics - Practice

On a test machine **install Puppet** if not already installed.

Practice with the **commands**:

   puppet describe
   puppet resource
   facter

Create a **manifest** file and in that file manage the installation of the package and the management of the service of *nginx*.
Use ```puppet apply``` to apply the resources declared in our manifest.
